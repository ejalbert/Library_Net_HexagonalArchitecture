import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// ESM equivalent of __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const GENERATED_CLIENT_PATH = path.resolve(__dirname, '../csharp-client/src/LibraryManagement.Api.Rest.Client.Generated');
const WRAPPER_OUTPUT_PATH = path.resolve(GENERATED_CLIENT_PATH, 'Wrapper');

interface ApiInfo {
  name: string;           // e.g., "Authors"
  className: string;      // e.g., "AuthorsApi"
  interfaceName: string;  // e.g., "IAuthorsApi"
  methods: MethodInfo[];
}

interface MethodInfo {
  name: string;           // e.g., "CreateAuthor"
  simpleName: string;     // e.g., "Create"
  returnType: string;     // e.g., "AuthorDto"
  parameters: ParameterInfo[];
  isAsync: boolean;
}

interface ParameterInfo {
  name: string;
  type: string;
}

/**
 * Parse API files to extract method signatures
 */
function parseApiFile(filePath: string): ApiInfo | null {
  const content = fs.readFileSync(filePath, 'utf-8');
  const fileName = path.basename(filePath, '.cs');

  if (!fileName.endsWith('Api')) return null;

  const name = fileName.replace('Api', '');
  const className = fileName;
  const interfaceName = `I${className}`;

  // Extract async method signatures from the interface
  const asyncInterfaceRegex = /interface\s+I\w+ApiAsync[\s\S]*?#region Asynchronous Operations([\s\S]*?)#endregion/;
  const asyncMatch = content.match(asyncInterfaceRegex);

  const methods: MethodInfo[] = [];

  if (asyncMatch) {
    const asyncSection = asyncMatch[1];

    // Match method signatures like: Task<AuthorDto> CreateAuthorAsync(CreateAuthorRequestDto dto, CancellationToken ct)
    const methodRegex = /System\.Threading\.Tasks\.Task(?:<([^>]+)>)?\s+(\w+)Async\(([^)]*)\)/g;
    let match;

    while ((match = methodRegex.exec(asyncSection)) !== null) {
      const returnType = match[1] || 'void';
      const methodName = match[2];
      const paramsStr = match[3];

      // Skip WithHttpInfo methods
      if (methodName.includes('WithHttpInfo')) continue;

      // Parse parameters (excluding operationIndex and cancellationToken)
      const parameters: ParameterInfo[] = [];
      if (paramsStr.trim()) {
        const params = paramsStr.split(',').map(p => p.trim());
        for (const param of params) {
          // Skip operationIndex and cancellationToken
          if (param.includes('operationIndex') || param.includes('cancellationToken')) continue;

          const parts = param.split(' ').filter(p => p);
          if (parts.length >= 2) {
            const type = parts.slice(0, -1).join(' ');
            const paramName = parts[parts.length - 1].replace('=', '').trim();
            parameters.push({ name: paramName, type });
          }
        }
      }

      // Keep the original method name without simplification
      let simpleName = methodName;

      methods.push({
        name: methodName,
        simpleName: simpleName || methodName,
        returnType,
        parameters,
        isAsync: true
      });
    }
  }

  return { name, className, interfaceName, methods };
}

/**
 * Generate the IRestApiClient interface
 */
function generateRestApiClientInterface(apis: ApiInfo[]): string {
  const properties = apis.map(api =>
    `    /// <summary>
    /// Gets the ${api.name} client for ${api.name.toLowerCase()}-related operations.
    /// </summary>
    I${api.name}Client ${api.name} { get; }`
  ).join('\n\n');

  return `// <auto-generated>
// This file was generated by the wrapper generator script.
// Do not modify this file directly.
// </auto-generated>

using System;
using System.Net.Http;

namespace LibraryManagement.Api.Rest.Client.Generated.Wrapper;

/// <summary>
/// Central REST API client interface providing access to all domain-specific clients.
/// </summary>
public interface IRestApiClient : IDisposable
{
    /// <summary>
    /// Gets the underlying HttpClient instance.
    /// </summary>
    HttpClient HttpClient { get; }

${properties}
}
`;
}

/**
 * Generate the RestApiClient implementation
 */
function generateRestApiClientImplementation(apis: ApiInfo[]): string {
  const fields = apis.map(api =>
    `    private readonly Lazy<I${api.name}Client> _${api.name.toLowerCase()};`
  ).join('\n');

  const constructorInit = apis.map(api =>
    `        _${api.name.toLowerCase()} = new Lazy<I${api.name}Client>(() => new ${api.name}ClientWrapper(this));`
  ).join('\n');

  const properties = apis.map(api =>
    `    /// <inheritdoc />
    public I${api.name}Client ${api.name} => _${api.name.toLowerCase()}.Value;`
  ).join('\n\n');

  return `// <auto-generated>
// This file was generated by the wrapper generator script.
// Do not modify this file directly.
// </auto-generated>

using System;
using System.Net.Http;

namespace LibraryManagement.Api.Rest.Client.Generated.Wrapper;

/// <summary>
/// Central REST API client implementation providing access to all domain-specific clients.
/// </summary>
public sealed class RestApiClient : IRestApiClient
{
    private readonly HttpClient _httpClient;
    private bool _disposed;

${fields}

    /// <summary>
    /// Initializes a new instance of the <see cref="RestApiClient"/> class.
    /// </summary>
    /// <param name="httpClient">The HttpClient instance to use for API calls.</param>
    public RestApiClient(HttpClient httpClient)
    {
        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        EnsureApiBasePath();

${constructorInit}
    }

    /// <inheritdoc />
    public HttpClient HttpClient => _httpClient;

${properties}

    private void EnsureApiBasePath()
    {
        if (_httpClient.BaseAddress == null) return;

        var basePath = _httpClient.BaseAddress.ToString().TrimEnd('/');
        if (!basePath.EndsWith("/api", StringComparison.OrdinalIgnoreCase))
        {
            basePath += "/api";
        }
        _httpClient.BaseAddress = new Uri($"{basePath}/");
    }

    /// <inheritdoc />
    public void Dispose()
    {
        if (_disposed) return;
        _disposed = true;
        // Note: We don't dispose the HttpClient as it's typically managed by IHttpClientFactory
    }
}
`;
}

/**
 * Generate a domain-specific client interface
 */
function generateClientInterface(api: ApiInfo): string {
  const asyncMethods = api.methods.map(method => {
    const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
    const paramsWithCt = params ? `${params}, CancellationToken cancellationToken = default` : 'CancellationToken cancellationToken = default';
    const returnType = method.returnType === 'void' ? 'Task' : `Task<${method.returnType}>`;

    return `    /// <summary>
    /// ${method.name} operation (async).
    /// </summary>
    ${returnType} ${method.simpleName}Async(${paramsWithCt});`;
  }).join('\n\n');

  const syncMethods = api.methods.map(method => {
    const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
    const returnType = method.returnType === 'void' ? 'void' : method.returnType;

    return `    /// <summary>
    /// ${method.name} operation (sync).
    /// </summary>
    ${returnType} ${method.simpleName}(${params});`;
  }).join('\n\n');

  return `// <auto-generated>
// This file was generated by the wrapper generator script.
// Do not modify this file directly.
// </auto-generated>

using System.Threading;
using System.Threading.Tasks;
using LibraryManagement.Api.Rest.Client.Generated.Model;

namespace LibraryManagement.Api.Rest.Client.Generated.Wrapper;

/// <summary>
/// Client interface for ${api.name.toLowerCase()}-related operations.
/// </summary>
public interface I${api.name}Client
{
    #region Asynchronous Operations

${asyncMethods}

    #endregion

    #region Synchronous Operations

${syncMethods}

    #endregion
}
`;
}

/**
 * Generate a domain-specific client wrapper implementation
 */
function generateClientWrapper(api: ApiInfo): string {
  const asyncMethods = api.methods.map(method => {
    const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
    const paramsWithCt = params ? `${params}, CancellationToken cancellationToken = default` : 'CancellationToken cancellationToken = default';
    const returnType = method.returnType === 'void' ? 'Task' : `Task<${method.returnType}>`;
    const callParams = method.parameters.map(p => p.name).join(', ');
    const callParamsWithCt = callParams ? `${callParams}, cancellationToken` : 'cancellationToken';
    const returnStatement = method.returnType === 'void' ? 'await' : 'return await';

    return `    /// <inheritdoc />
    public async ${returnType} ${method.simpleName}Async(${paramsWithCt})
    {
        ${returnStatement} _api.${method.name}Async(${callParamsWithCt}).ConfigureAwait(false);
    }`;
  }).join('\n\n');

  const syncMethods = api.methods.map(method => {
    const params = method.parameters.map(p => `${p.type} ${p.name}`).join(', ');
    const returnType = method.returnType === 'void' ? 'void' : method.returnType;
    const callParams = method.parameters.map(p => p.name).join(', ');
    const returnStatement = method.returnType === 'void' ? '' : 'return ';

    return `    /// <inheritdoc />
    public ${returnType} ${method.simpleName}(${params})
    {
        ${returnStatement}_api.${method.name}(${callParams});
    }`;
  }).join('\n\n');

  return `// <auto-generated>
// This file was generated by the wrapper generator script.
// Do not modify this file directly.
// </auto-generated>

using System.Threading;
using System.Threading.Tasks;
using LibraryManagement.Api.Rest.Client.Generated.Api;
using LibraryManagement.Api.Rest.Client.Generated.Model;

namespace LibraryManagement.Api.Rest.Client.Generated.Wrapper;

/// <summary>
/// Wrapper implementation for ${api.name.toLowerCase()}-related operations.
/// </summary>
internal sealed class ${api.name}ClientWrapper : I${api.name}Client
{
    private readonly ${api.className} _api;

    public ${api.name}ClientWrapper(IRestApiClient client)
    {
        _api = new ${api.className}(client.HttpClient);
    }

    #region Asynchronous Operations

${asyncMethods}

    #endregion

    #region Synchronous Operations

${syncMethods}

    #endregion
}
`;
}

/**
 * Generate DI extension methods for registering the client
 */
function generateServiceCollectionExtensions(apis: ApiInfo[]): string {
  const interfaceRegistrations = apis.map(api =>
    `            services.AddScoped<I${api.name}Client>(sp => sp.GetRequiredService<IRestApiClient>().${api.name});`
  ).join('\n');

  return `// <auto-generated>
// This file was generated by the wrapper generator script.
// Do not modify this file directly.
// </auto-generated>

using System;
using System.Net.Http;
using Microsoft.Extensions.DependencyInjection;

namespace LibraryManagement.Api.Rest.Client.Generated.Wrapper;

/// <summary>
/// Extension methods for registering the REST API client with dependency injection.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Adds the REST API client to the service collection.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="configureClient">Optional action to configure the HttpClient.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddLibraryManagementRestApiClient(
        this IServiceCollection services,
        Action<HttpClient>? configureClient = null)
    {
        services.AddHttpClient<IRestApiClient, RestApiClient>(client =>
        {
            configureClient?.Invoke(client);
        });

        // Register individual domain clients
${interfaceRegistrations}

        return services;
    }

    /// <summary>
    /// Adds the REST API client to the service collection with a base address.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="baseAddress">The base address of the API.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddLibraryManagementRestApiClient(
        this IServiceCollection services,
        string baseAddress)
    {
        return services.AddLibraryManagementRestApiClient(client =>
        {
            client.BaseAddress = new Uri(baseAddress);
        });
    }

    /// <summary>
    /// Adds the REST API client to the service collection with a base URI.
    /// </summary>
    /// <param name="services">The service collection.</param>
    /// <param name="baseAddress">The base URI of the API.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddLibraryManagementRestApiClient(
        this IServiceCollection services,
        Uri baseAddress)
    {
        return services.AddLibraryManagementRestApiClient(client =>
        {
            client.BaseAddress = baseAddress;
        });
    }
}
`;
}

/**
 * Patch the csproj file to add required package references for the wrapper
 */
function patchCsprojFile(): void {
  const csprojPath = path.join(GENERATED_CLIENT_PATH, 'LibraryManagement.Api.Rest.Client.Generated.csproj');

  if (!fs.existsSync(csprojPath)) {
    console.error('csproj file not found. Run codegen:csharp first.');
    return;
  }

  let content = fs.readFileSync(csprojPath, 'utf-8');

  // Check if the packages are already added
  if (content.includes('Microsoft.Extensions.Http')) {
    console.log('  Package references already present in csproj');
    return;
  }

  // Add the required packages after the existing PackageReference items
  const packageReferencesToAdd = `
    <PackageReference Include="Microsoft.Extensions.Http" Version="8.0.0" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection.Abstractions" Version="8.0.0" />`;

  // Find the last PackageReference and add after it
  const lastPackageRefIndex = content.lastIndexOf('</PackageReference>');
  if (lastPackageRefIndex !== -1) {
    const insertPosition = lastPackageRefIndex + '</PackageReference>'.length;
    content = content.slice(0, insertPosition) + packageReferencesToAdd + content.slice(insertPosition);
    fs.writeFileSync(csprojPath, content);
    console.log('  Added package references to csproj');
  }
}

/**
 * Main function to generate all wrapper classes
 */
function generateWrapperClasses(): void {
  console.log('Generating wrapper classes...');

  // Ensure output directory exists
  if (!fs.existsSync(WRAPPER_OUTPUT_PATH)) {
    fs.mkdirSync(WRAPPER_OUTPUT_PATH, { recursive: true });
  }

  // Find and parse all API files
  const apiDir = path.join(GENERATED_CLIENT_PATH, 'Api');
  if (!fs.existsSync(apiDir)) {
    console.error('API directory not found. Run codegen:csharp first.');
    process.exit(1);
  }

  const apiFiles = fs.readdirSync(apiDir).filter(f => f.endsWith('Api.cs'));
  const apis: ApiInfo[] = [];

  for (const file of apiFiles) {
    const apiInfo = parseApiFile(path.join(apiDir, file));
    if (apiInfo && apiInfo.methods.length > 0) {
      apis.push(apiInfo);
      console.log(`  Parsed ${apiInfo.name} with ${apiInfo.methods.length} methods`);
    }
  }

  if (apis.length === 0) {
    console.error('No API files found or parsed.');
    process.exit(1);
  }

  // Generate files
  console.log('\nGenerating wrapper files...');

  // 1. IRestApiClient interface
  const restApiClientInterface = generateRestApiClientInterface(apis);
  fs.writeFileSync(path.join(WRAPPER_OUTPUT_PATH, 'IRestApiClient.cs'), restApiClientInterface);
  console.log('  Generated IRestApiClient.cs');

  // 2. RestApiClient implementation
  const restApiClientImpl = generateRestApiClientImplementation(apis);
  fs.writeFileSync(path.join(WRAPPER_OUTPUT_PATH, 'RestApiClient.cs'), restApiClientImpl);
  console.log('  Generated RestApiClient.cs');

  // 3. Domain-specific client interfaces and wrappers
  for (const api of apis) {
    const clientInterface = generateClientInterface(api);
    fs.writeFileSync(path.join(WRAPPER_OUTPUT_PATH, `I${api.name}Client.cs`), clientInterface);
    console.log(`  Generated I${api.name}Client.cs`);

    const clientWrapper = generateClientWrapper(api);
    fs.writeFileSync(path.join(WRAPPER_OUTPUT_PATH, `${api.name}ClientWrapper.cs`), clientWrapper);
    console.log(`  Generated ${api.name}ClientWrapper.cs`);
  }

  // 4. ServiceCollectionExtensions for DI
  const diExtensions = generateServiceCollectionExtensions(apis);
  fs.writeFileSync(path.join(WRAPPER_OUTPUT_PATH, 'ServiceCollectionExtensions.cs'), diExtensions);
  console.log('  Generated ServiceCollectionExtensions.cs');

  // 5. Patch csproj with required package references
  patchCsprojFile();

  console.log('\nWrapper generation completed successfully!');
}

// Run
generateWrapperClasses();

